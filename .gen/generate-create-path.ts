import ts from 'typescript';
import { readSourceFile, writeOutputFile } from './utils';

const sourceFile = await readSourceFile('../src/pages.gen.ts');

let output = '';

ts.forEachChild(sourceFile, (node) => {
	if (
		ts.isTypeAliasDeclaration(node) &&
		node.name.text === 'Page' &&
		ts.isUnionTypeNode(node.type)
	) {
		const paths = node.type.types
			.filter(ts.isParenthesizedTypeNode)
			.map((n) => n.type)
			.filter(ts.isIntersectionTypeNode)
			.map((n) => n.types[0])
			.filter((n) => !!n)
			.filter(ts.isTypeLiteralNode)
			.map((n) => n.members[0])
			.filter((n) => !!n)
			.filter(ts.isPropertySignature)
			.map((n) => n.type)
			.filter((n) => !!n)
			.filter(ts.isLiteralTypeNode)
			.map((n) => n.literal)
			.filter(ts.isStringLiteral)
			.map((n) => n.text);

		const thing = paths.map((p) => {
			const params = p.match(/\[(\w+)\]/g)?.map((m) => m.slice(1, -1)) ?? [];
			if (params.length > 0) {
				return { path: p, params };
			}

			return { path: p };
		});

		const withoutParams = thing.filter((t) => !t.params);
		const withParams = thing.filter((t) => t.params);

		const pathsWithoutParamsType =
			withoutParams.length > 0
				? `type WithoutParams = ${withoutParams.map((t) => `'${t.path}'`).join(' | ')};`
				: '';
		const pathsWithParamsType =
			withParams.length > 0
				? `type WithParams = {
						${withParams
							.map(
								(t) =>
									`'${t.path}': { ${t.params?.map((p) => `${p}: string; `)} }`,
							)
							.join('\n')}
					};`
				: '';

		output = `
			/* generated by .gen/generate-create-path.ts */

      ${pathsWithoutParamsType}
      ${pathsWithParamsType}
      
			export function createPath<T extends WithoutParams>(path: T): string;
			export function createPath<T extends keyof WithParams>(
				path: T,
				params: WithParams[T],
			): string;
			export function createPath(p: string, params?: Record<string, string>): string {
				if (!params) return p;
				let result = p;
				for (const [key, value] of Object.entries(params)) {
					result = result.replace(\`[\${key}]\`, value);
				}
				return result;
			}
    `;
	}
});

if (output) {
	writeOutputFile(output, '../src/utils/create-path.gen.ts', '../biome.json');
}
